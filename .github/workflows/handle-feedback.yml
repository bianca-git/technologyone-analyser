name: Handle App Feedback
on:
  repository_dispatch:
    types: [app-feedback]

# 1. PERMISSIONS: Grants the internal token rights to modify issues
permissions:
  issues: write
  contents: read

jobs:
  process-feedback:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Create the Issue & Notify You
      - name: Create GitHub Issue
        id: create_issue
        uses: actions/github-script@v7
        with:
          script: |
            const feedback = context.payload.client_payload.feedback;
            const reporter = context.payload.client_payload.reporter;

            // This triggers your Mobile Notification immediately
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[Feedback] Input from ${reporter}`,
              body: `**Reporter:** ${reporter}\n\n**Raw Feedback:**\n${feedback}`,
              assignees: ['bianca-git']
            });

            core.setOutput('issue_number', issue.data.number);

      # Step 2: Analyze, Label, & Auto-Close
      - name: AI Triage & Spam Assassin (GPT-5.2)
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          FEEDBACK: ${{ github.event.client_payload.feedback }}
          ISSUE_NUM: ${{ steps.create_issue.outputs.issue_number }}
        with:
          script: |
            // 1. Configure the 2026 Payload (v1/responses)
            const payload = {
              model: "gpt-5.2",
              reasoning: { effort: "low" }, // Save cost on simple triage
              input: `You are a triage bot. Analyze this feedback: "${process.env.FEEDBACK}".
                      Return a JSON object with:
                      - classification: "SPAM" or "VALID"
                      - category: "bug", "feature", or "ux"
                      - reply: "Short markdown technical response"`,
              
              // New Structured Output Syntax for GPT-5
              text: {
                format: {
                  type: "json_schema",
                  schema: {
                    type: "object",
                    properties: {
                      classification: { type: "string", enum: ["SPAM", "VALID"] },
                      category: { type: "string", enum: ["bug", "feature", "ux"] },
                      reply: { type: "string" }
                    },
                    required: ["classification", "category", "reply"],
                    additionalProperties: false
                  }
                }
              }
            };

            // 2. Call OpenAI (v1/responses)
            const response = await fetch('https://api.openai.com/v1/responses', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
              },
              body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error(`OpenAI API Error: ${response.statusText}`);

            const data = await response.json();

            // 3. Parse Output (Note: v1/responses returns 'output_text' at top level for convenience)
            // If raw JSON schema is strict, we parse the text string.
            const result = JSON.parse(data.output_text || data.items[0].content[0].text);
            const issue_number = parseInt(process.env.ISSUE_NUM);

            // 4. Action Logic (Same as before)
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: `### ðŸ¤– GPT-5.2 Analysis: ${result.classification}\n\n**Category:** ${result.category}\n\n${result.reply}`
            });

            if (result.classification === "SPAM") {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
                labels: ['spam', 'wontfix']
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
                state: 'closed'
              });
            } else {
               await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
                labels: ['triage', result.category.toLowerCase()]
              });
            }
