name: Handle App Feedback
on:
  repository_dispatch:
    types: [app-feedback]

# 1. PERMISSIONS: Grants the internal token rights to modify issues
permissions:
  issues: write
  contents: read

jobs:
  process-feedback:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Create the Issue & Notify You
      - name: Create GitHub Issue
        id: create_issue
        uses: actions/github-script@v7
        with:
          script: |
            const feedback = context.payload.client_payload.feedback;
            const reporter = context.payload.client_payload.reporter;

            // This triggers your Mobile Notification immediately
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[Feedback] Input from ${reporter}`,
              body: `**Reporter:** ${reporter}\n\n**Raw Feedback:**\n${feedback}`,
              assignees: ['bianca-git']
            });

            core.setOutput('issue_number', issue.data.number);

      # Step 2: Analyze, Label, & Auto-Close
      - name: AI Triage & Spam Assassin (GPT-5.2)
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          FEEDBACK: ${{ github.event.client_payload.feedback }}
          ISSUE_NUM: ${{ steps.create_issue.outputs.issue_number }}
        with:
          script: |
            // 1. Configure the 2026 Payload (v1/responses)
            const payload = {
              prompt: {
                id: "pmpt_696d5dc776d481949cd2c59100d1c716021abdc584703216",
                version: "1"
              },
              input: [process.env.FEEDBACK],
              text: {
                format: {
                  type: "json_schema",
                  name: "classified_response",
                  strict: true,
                  schema: {
                    type: "object",
                    properties: {
                      classification: {
                        type: "string",
                        description: "Overall label for the content",
                        enum: [
                          "SPAM",
                          "VALID"
                        ]
                      },
                      category: {
                        type: "string",
                        description: "Specific type of request or comment",
                        enum: [
                          "bug",
                          "feature",
                          "ux"
                        ]
                      },
                      reply: {
                        type: "string",
                        description: "Assistant's written response"
                      }
                    },
                    required: [
                      "classification",
                      "category",
                      "reply"
                    ],
                    additionalProperties: false
                  }
                }
              },
              reasoning: {},
              store: true,
              include: [
                "reasoning.encrypted_content",
                "web_search_call.action.sources"
              ]
            };

            // 2. Call OpenAI (v1/responses)
            const response = await fetch('https://api.openai.com/v1/responses', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
              },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.log('API Error Body:', errorText);
              throw new Error(`OpenAI API Error: ${response.statusText}`);
            }

            const data = await response.json();

            // 3. Parse Output (Note: v1/responses returns 'output_text' at top level for convenience)
            // If raw JSON schema is strict, we parse the text string.
            const result = JSON.parse(data.output_text || data.items[0].content[0].text);
            const issue_number = parseInt(process.env.ISSUE_NUM);

            // 4. Action Logic (Same as before)
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: `### ðŸ¤– GPT-5.2 Analysis: ${result.classification}\n\n**Category:** ${result.category}\n\n${result.reply}`
            });

            if (result.classification === "SPAM") {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
                labels: ['spam', 'wontfix']
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
                state: 'closed'
              });
            } else {
               await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
                labels: ['triage', result.category.toLowerCase()]
              });
            }
